## 학습 정리

### 2강
#### 다중 토큰 : Refresh 토큰과 생명 주기
- AccessToken만 사용했을때 로그인을 지속시키기 위해 만료시간을 길게할 경우 탈취당하면 심각한 보안 문제가 있다.
- 탈취를 방지하고 탈취당했을 경우를 대비하기 위해 RefreshToken 개념이 등장했다.
- AccessToken은 짧게(ex. 10분), RefreshToken은 길게(ex. 24시간) 설정하여 토큰을 발급한다.
  - AccessToken 생명 주기가 짧으면 매번 로그인을 진행해야 한다.
  - 생명주기가 긴 Refresh 토큰을 발급하여 로그인을 지속시킨다.
  - 10분마다 AccessToken을 재발급 받는 요청으로 서버에 부하가 고민된다면 인증서버 분리 + 레디스 사용으로 부하방지를 할수 있을 것 같다.
- Access 토큰 : 권한이 필요한 모든 요청 헤더에 사용될 JWT로 탈취 위험을 낮추기 위해 약 10분 정도의 짧은 생명주기를 가진다.
- Refresh 토큰 : Access 토큰이 만료되었을 때 재발급 받기 위한 용도로만 사용되며 약 24시간 이상의 긴 생명주기를 가진다.

#### Refresh 토큰이 탈취되는 경우
- 생명주기가 짧은 Access 토큰은 탈취당하더라도 피해 확률이 낮다.
- 하지만 Refresh 토큰 또한 탈취될 수 있는 확률이 존재하여 보호 방법이 필요하다.
1. Access / Refresh 토큰의 저장 위치 고려
- 로컬 / 세션 스토리지 및 쿠키에 따라 XSS, CSRF 공격의 여부가 결정되기 때문에 각 토큰 사용처에 알맞은 저장소 설정
2. Refresh 토큰 Rotate
- Access 토큰을 갱신하기 위한 Refresh 토큰 요청 시 서버측에서 Refresh 토큰도 재발급을 진행하여 한번 사용한 Refresh 토큰을 재사용하지 못하게 한다.

#### Access/Refresh 토큰 저장 위치
- 클라이언트에서는 발급 받은 JWT를 로컬 스토리지나 쿠키 중 고민을 많이 한다.
- 각 스토리지에 대한 특징과 취약점
  - 로컬 스토리지 : XSS 공격에 취약함 / Access 토큰 저장
  - httpOnly 쿠키 : CSRF 공격에 취약함 / Refresh 토큰 저장
- Access 토큰
  - 주로 로컬 스토리지에 저장됩니다.  
  - 권한이 필요한 모든 경로에 사용되기 때문에 CSRF 공격을 받게 되면 위험하다.
  - 그래서 쿠키에 저장하기 보단 로컬 스토리지에 저장하여 XSS 공격을 최대한 방어하는 로직을 작성하는것이 안전하다.
- Refresh 토큰
  - 주로 쿠키에 저장됩니다.
  - 쿠키는 XSS 공격을 받을 수 있지만, httpOnly를 설정하면 방어 가능합니다.
    - httponly: 쿠키를 설정할 때 httponly를 true로 설정하면 자바스크립트에서 쿠키에 접근할 수 없다.
  - CSRF 공격에 위험하다고 생각할 수 있지만, Refresh의 토큰의 사용처는 Access 토큰을 재발급 받는 API 하나뿐이다.
  - CSRF는 Access 토큰이 접근하는 회원 정보 수정, 게시글 CRUD에는 추이갸할 수 있습니다. 비즈니스 로직이 있다.
  - 따라서, 토큰 재발급 API에서는 크게 피해를 입힐만한 로직이 없습니다.

#### Refresh 토큰 Rotate
- 생명주기가 긴 Refresh 토큰에 대한 추가적인 방어 조치가 있습니다.
- Access 토큰이 만료되어 Refresh 토큰을 가지고 재발급을 요청할 때, Refresh 토큰 또한 재발급하는 것 입니다.
- Refresh 토큰은 일회성 토큰이 되버린다. 따라서 탈취당해도 한번 사용을 한 토큰이기 때문에 재사용할 수 없게 된다.
  - Replay attack로부터 보호할 수 있다.
    - Replay attack: 공격자가 원본 메시지와 같은 자격증명을 얻기 위해 이전에 보내진 메시지를 가로채서 다시 보내는 것 
- 이전에 사용된 Refresh Token이 인증 서버로 전송되면 이는 탈취되었다는 증거가 되기 때문에 최근에 발행된 Refresh Token도 모두 무효화 해야 한다.
  - 기존 refresh 토큰을 삭제해줘야 한다. 
  - 사용자가 공격자 보다 먼저 AccessToken 재발급을 요청
    - 사용자가 먼저 요청을 보내면 공격자의 RefreshToken(이전 버전)도 무효화 된다.
  - 공격자가 사용자 보다 먼저 AccessToken 재발급을 요청
    - 공격자가 먼저 탈취한 RefreshToken으로 AccessToken을 재발급 받아도 사용자가 먼저 기존의 RefreshToken으로 요청을 보내면 공격자의 RefreshToken도 무효화 된다.
    - '공격자가 탈취한 시간 ~ 사용자가 요청을 보내는 시간' 사이에는 취약할 수 있을 것 같다.
  - 서버는 감지된 재사용 이벤트를 로그에 캡처해야 한다. (추적을 위함)
- 재 로그인이 있을 때 까지는 후속 요청은 거부된다.
- redis를 사용하면 ttl을 설정해 자동으로 refresh 토큰을 삭제할 수 있다. rdbms에 저장하면 만료시간이 지난 토큰은 삭제해주는 스케줄 작업을 추가해줘야 한다.

#### 로그아웃과 Refresh 토큰 주도권
- 로그아웃을 하게 되면 Refresh 토큰이 무효화 되어야 한다.
- 프론트에서는 삭제되지만 그전에 공격자가 JWT를 복제했다면 서버측에선 할수 있는게 없다.(주도권이 없기 때문)
- 방어 방법
  - 서버측 저장소에도 Refresh 토큰을 저장해서 요청이 올때마다 저장소에 존재하는지 확인
    - 없는 토큰으로 요청했을 경우 Refresh 토큰 Rotate에 적은 내용과 같이 모든 토큰을 무효화
  - 로그아웃을 진행했을땐 저장소에 저장된 Refresh 토큰을 삭제 (Refresh 토큰 블랙 리스트) + 쿠키도 초기화

#### 로그인시 메일 알림
- 네이버 사용시 베트남, 중국 이런데서 로그인 되었다는 알림이 올것이다.
  - 평소 사용하지 않던 IP나 브라우저에거 접근을 할경우 사용자의 계정으로 메일 알림이 옴
  - 다른곳에서 로그인을 시도한 사람은 대기중. 메일에서 승인을 눌러야 로그인 가능
- 아니요를 누르면 서버측 토큰 저장소에서 해당 유저에 대한 refresh 토큰을 모두 제거하여 앞으로의 인증을 막을 수 있음

### 4강
```java
        response.setHeader("Authorzation", "Bearer " + access);
        response.addCookie(createCookie("refresh", refresh));
```
- Authorization 헤더에 토큰을 포함시킬 때는 "Bearer"를 붙이는 것이 일반적이다.
- 그러나 쿠키에는 Bearer 접두사를 포함시키지 않는게 일반적이다.
- 이는 쿠키값에 공백이 포함되어 있으면 문제를 일으킬 수 있기 때문입니다.

- 구글 로그인후 리다이렉트 URL에 헤더를 추가해야 하는데 하기 힘들때는 쿠키를 사용하면 된다.
- 2가지 방법이 있다.
1. Access 토큰도 쿠키로 발급하고 아주 짧은 시간동안 획득할 수 있게 설정한 뒤 프론트측에서 쿠키를 통해 Access 를 획득하고 쿠키 소멸. (아주 좋은 방법인거 같습니다.)
2. Refresh만 발급 후 추후 Access 토큰 사용시 프론트측에서 Reissue 경로를 통해 Access 토큰을 발급 받도록 진행하기. (또는 로그인 완료 후 Refresh만 발급 후 프론트의 특정 경로로 리디렉션 시키고, 
프론트 해당 경로에서 axios를 활용해 Refresh를 통한 Access 토큰을 요청)

### 10강


